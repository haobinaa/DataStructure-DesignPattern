### 动态规划详解

动态规划是自底向上的解法

#### 状态转移方程

1. 明确 base case， 即基线条件(最底层的条件)
2. 明确状态， 原问题和子问题中变化的量
3. 明确选择， 导致状态变化的行为
4. 定义 dp 数组/函数定义

以凑零钱问题为例子:
``` 
给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1

// coins 中是可选硬币面值，amount 是目标金额
int coinChange(int[] coins, int amount);
```

1. base case: 目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了

2. 确定状态： 也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的状态就是目标金额 `amount`

3. 确定选择： 也就是导致状态产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的选择

4. 明确 dp 数组/函数： 自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的状态；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即目标金额，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：
``` 
dp(n) 的定义：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量
```